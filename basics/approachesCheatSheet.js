//BFS & Queue:

//DFS:

//Divide and conquer:
//  binary search

//Backtracking algorithm:
//find all possible routes that go from first node to end node and prune recursion for routes that fail

//Dynamic Programming algorithm
// As a reminder, with DP, we break the original problem down to several sub-problems recursively until the sub-problems are small enough to be solved directly. Then we combine the results of sub-problems to obtain the final solution for the original problem.

//   divide and conqure
//binary search
//  top down
// --memoization
//  bottom up
// --tabloidization
///////////////////////////////
//linked lists
//doubly linked lists
//hashed linked lists

//directed graph cycling
//topilogical sort with DFS using hashed nodes

//adjacency graph

//Dynamic Programming
//  1. backtracking (if applicable)
//  2. top down
//  3. top down w/ memoization
//  4. bottom up w/ tabloidization

//binary tree
//  1. recursive
//  2. iterative stack
//  3. iterative
//      morris traversal
